// template_new_wasm_mod.rs

//! template for new_wasm
//!
//! An automation task copy the content of the template_new_wasm folder into this strings.
//! When installing a crate from crates.io, only the code is transferred. No additional files.

use crate::{GREEN, RED, RESET, YELLOW};

pub fn new_wasm(arg_2: Option<String>) {
    match arg_2 {
        None => println!("{RED}Error: Project name argument is missing: `cargo auto new_wasm project_name`{RESET}"),
        Some(project_name) => {
            copy_to_files(&project_name);
            println!("");
            println!("    {YELLOW}The command `crate auto new_wasm` generated the directory `{project_name}`{RESET}");
            println!("    {YELLOW}You can open this new Rust project `{project_name}` in a new Rust editor.{RESET}",);
            println!("    {YELLOW}For example VSCode:{RESET}");
            println!("{GREEN}code {project_name}{RESET}");
            println!("    {YELLOW}Then build with:{RESET}");
            println!("{GREEN}cargo auto build{RESET}");
            println!("    {YELLOW}and follow the detailed instructions.{RESET}");
        }
    }
}

pub fn copy_to_files(project_name: &str) {
    let folder_path = std::path::Path::new(project_name);
    std::fs::create_dir_all(folder_path).unwrap();
    for file_item in get_vec_file() {
        // rename/replace the project_name
        let file_name = file_item.file_name.replace("cargo_auto_template_new_wasm", project_name);
        let file_content = file_item.file_content.replace("cargo_auto_template_new_wasm", project_name);

        // create directory if needed
        std::fs::create_dir_all(folder_path.join(&file_name).parent().unwrap()).unwrap();
        std::fs::write(folder_path.join(&file_name), file_content.as_bytes()).unwrap();
    }
}

pub fn get_vec_file() -> Vec<crate::FileItem> {
    let mut vec_file = vec![];

    // region: files copied into strings by automation tasks
    vec_file.push(crate::FileItem {
        file_name: ".gitattributes",
        file_content: r###"# Specific git config for the project

# Declare files that will always have LF line endings on checkout.
*.rs text eol=lf
*.toml text eol=lf
*.md text eol=lf
*.json text eol=lf
*.json5 text eol=lf
*.lock text eol=lf
*.yml text eol=lf
*.html text eol=lf
*.js text eol=lf
*.css text eol=lf
LICENSE text eol=lf
.gitignore text eol=lf
.gitattributes text eol=lf
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: ".gitignore",
        file_content: r###"# Generated by Cargo
# will have compiled files and executables
/target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
# Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# result of compilation does not need to go to repository
/pkg/

# not needed in commits, but also not a problem if they are committed
/.automation_tasks_rs_file_hashes.json
/.auto_version_from_date.json
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/rustfmt.toml",
        file_content: r###"max_width = 200"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/.gitignore",
        file_content: r###"/target
/logs

# so the GitHub action gets the fresh libraries
Cargo.lock

# not needed in commits, but also not a problem if they are committed
/.file_hashes.json
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/src/main.rs",
        file_content: r###"// automation_tasks_rs for cargo_auto_template_new_wasm

// region: library and modules with basic automation tasks

// for projects that don't use GitHub, delete all the mentions of GitHub
mod secrets_always_local_mod;
use crate::secrets_always_local_mod::crate_io_mod;
use crate::secrets_always_local_mod::github_mod;

use cargo_auto_github_lib as cgl;
use cargo_auto_lib as cl;

use cl::GREEN;
use cl::RED;
use cl::RESET;
use cl::YELLOW;

// traits must be in scope (Rust strangeness)
use cgl::SendToGitHubApi;
use cl::CargoTomlPublicApiMethods;
use cl::ShellCommandLimitedDoubleQuotesSanitizerTrait;

// region: library with basic automation tasks

fn main() {
    std::panic::set_hook(Box::new(|panic_info| panic_set_hook(panic_info)));
    tracing_init();
    cl::exit_if_not_run_in_rust_project_root_directory();

    // get CLI arguments
    let mut args = std::env::args();
    // the zero argument is the name of the program
    let _arg_0 = args.next();
    match_arguments_and_call_tasks(args);
}

// region: general functions

/// Initialize tracing to file logs/automation_tasks_rs.log
///
/// The folder logs/ is in .gitignore and will not be committed.
pub fn tracing_init() {
    let file_appender = tracing_appender::rolling::daily("logs", "automation_tasks_rs.log");

    let offset = time::UtcOffset::current_local_offset().expect("should get local offset!");
    let timer = tracing_subscriber::fmt::time::OffsetTime::new(offset, time::macros::format_description!("[hour]:[minute]:[second].[subsecond digits:6]"));

    // Filter out logs from: hyper_util, reqwest
    // A filter consists of one or more comma-separated directives
    // target[span{field=value}]=level
    // examples: tokio::net=info
    // directives can be added with the RUST_LOG environment variable:
    // export RUST_LOG=automation_tasks_rs=trace
    // Unset the environment variable RUST_LOG
    // unset RUST_LOG
    let filter = tracing_subscriber::EnvFilter::from_default_env()
        .add_directive("hyper_util=error".parse().unwrap())
        .add_directive("reqwest=error".parse().unwrap());

    tracing_subscriber::fmt()
        .with_file(true)
        .with_max_level(tracing::Level::DEBUG)
        .with_timer(timer)
        .with_line_number(true)
        .with_ansi(false)
        .with_writer(file_appender)
        .with_env_filter(filter)
        .init();
}

/// The original Rust report of the panic is ugly for the end user
///
/// I use panics extensively to stop the execution. I am lazy to implement a super complicated error handling.
/// I just need to stop the execution on every little bit of error. This utility is for developers. They will understand me.
/// For errors I print the location. If the message contains "Exiting..." than it is a "not-error exit" and  the location is not important.
fn panic_set_hook(panic_info: &std::panic::PanicInfo) {
    let mut string_message = "".to_string();
    if let Some(message) = panic_info.payload().downcast_ref::<String>() {
        string_message = message.to_owned();
    }
    if let Some(message) = panic_info.payload().downcast_ref::<&str>() {
        string_message.push_str(message);
    }

    tracing::debug!("{string_message}");
    eprintln!("{string_message}");

    if !string_message.contains("Exiting...") {
        let file = panic_info.location().unwrap().file();
        let line = panic_info.location().unwrap().line();
        let column = panic_info.location().unwrap().column();
        tracing::debug!("Location: {file}:{line}:{column}");
        eprintln!("Location: {file}:{line}:{column}");
    }
}

// endregion: general functions

// region: match, help and completion

/// match arguments and call tasks functions
fn match_arguments_and_call_tasks(mut args: std::env::Args) {
    // the first argument is the user defined task: (no argument for help), build, release,...
    let arg_1 = args.next();
    match arg_1 {
        None => print_help(),
        Some(task) => {
            if &task == "completion" {
                completion();
            } else {
                println!("{YELLOW}Running automation task: {task}{RESET}");
                if &task == "build" {
                    task_build();
                } else if &task == "release" {
                    task_release();
                } else if &task == "doc" {
                    task_doc();
                } else if &task == "test" {
                    task_test();
                } else if &task == "commit_and_push" {
                    let arg_2 = args.next();
                    task_commit_and_push(arg_2);
                } else if &task == "publish_to_web" {
                    task_publish_to_web();
                } else if &task == "github_new_release" {
                    task_github_new_release();
                } else {
                    eprintln!("{RED}Error: Task {task} is unknown.{RESET}");
                    print_help();
                }
            }
        }
    }
}

/// write a comprehensible help for user defined tasks
fn print_help() {
    println!(
        r#"
    {YELLOW}Welcome to cargo-auto !{RESET}
    {YELLOW}This program automates your custom tasks when developing a Rust project.{RESET}

    {YELLOW}User defined tasks in automation_tasks_rs:{RESET}
{GREEN}cargo auto build{RESET} - {YELLOW}builds the crate in debug mode, fmt, increment version{RESET}
{GREEN}cargo auto release{RESET} - {YELLOW}builds the crate in release mode, fmt, increment version{RESET}
{GREEN}cargo auto doc{RESET} - {YELLOW}builds the docs, copy to docs directory{RESET}
{GREEN}cargo auto test{RESET} - {YELLOW}runs all the tests{RESET}
{GREEN}cargo auto commit_and_push "message"{RESET} - {YELLOW}commits with message and push with mandatory message{RESET}
    {YELLOW}It is preferred to use SSH for git push to GitHub.{RESET}
    {YELLOW}<https://github.com/CRUSTDE-ContainerizedRustDevEnv/crustde_cnt_img_pod/blob/main/ssh_easy.md>{YELLOW}
    {YELLOW}On the very first commit, this task will initialize a new local git repository and create a remote GitHub repo.{RESET}
    {YELLOW}For the GitHub API the task needs the Personal Access Token Classic from <https://github.com/settings/tokens>{RESET}
    {YELLOW}You can choose to type the token every time or to store it in a file encrypted with an SSH key.{RESET}
    {YELLOW}Then you can type the passphrase of the private key every time. This is pretty secure.{RESET}
    {YELLOW}Somewhat less secure (but more comfortable) way is to store the private key in ssh-agent.{RESET}
{GREEN}cargo auto publish_to_web - publish to web, git tag{RESET}
    {YELLOW}It is preferred to use SSH to publish to web and remotely manage the web server.{RESET}
    {YELLOW}<https://github.com/CRUSTDE-ContainerizedRustDevEnv/crustde_cnt_img_pod/blob/main/ssh_easy.md>{YELLOW}
{GREEN}cargo auto github_new_release{RESET} - {YELLOW}creates new release on GitHub{RESET}
    {YELLOW}For the GitHub API the task needs the Personal Access Token Classic from <https://github.com/settings/tokens>{RESET}
    {YELLOW}You can choose to type the token every time or to store it in a file encrypted with an SSH key.{RESET}
    {YELLOW}Then you can type the passphrase of the private key every time. This is pretty secure.{RESET}
    {YELLOW}Somewhat less secure (but more comfortable) way is to store the private key in ssh-agent.{RESET}

    {YELLOW}© 2024 bestia.dev  MIT License github.com/automation-tasks-rs/cargo-auto{RESET}
"#
    );
    print_examples_cmd();
}

/// all example commands in one place
fn print_examples_cmd() {
/*
    println!(r#"{YELLOW}run examples:{RESET}
{GREEN}cargo run --example example1{RESET}
"#);
*/
}

/// sub-command for bash auto-completion of `cargo auto` using the crate `dev_bestia_cargo_completion`
fn completion() {
    let args: Vec<String> = std::env::args().collect();
    let word_being_completed = args[2].as_str();
    let last_word = args[3].as_str();

    if last_word == "cargo-auto" || last_word == "auto" {
        let sub_commands = vec!["build", "release", "doc", "test", "commit_and_push", "publish_to_web", "github_new_release",];
        cl::completion_return_one_or_more_sub_commands(sub_commands, word_being_completed);
    }
    /*
    // the second level if needed
    else if last_word == "new" {
        let sub_commands = vec!["x"];
       cl::completion_return_one_or_more_sub_commands(sub_commands, word_being_completed);
    }
    */
}

// endregion: match, help and completion

// region: tasks

/// wasm-pack build
fn task_build() {
    let cargo_toml = cl::CargoToml::read();
    cl::auto_version_increment_semver_or_date();
    cl::run_shell_command_static("cargo fmt").unwrap_or_else(|e| panic!("{e}"));
    cl::run_shell_command_static("wasm-pack build --target web").unwrap_or_else(|e| panic!("{e}"));;
    cl::run_shell_command_static("\\rsync -a --delete-after pkg/ web_server_folder/cargo_auto_template_new_wasm/pkg/").unwrap_or_else(|e| panic!("{e}"));;
    println!(
        r#"
    {YELLOW}After `cargo auto build`, open port 4000 in VSCode and run the basic web server{RESET}
    {YELLOW}in a separate VSCode bash terminal, so it can serve constantly in the background.{RESET}
{GREEN}basic-http-server -a 0.0.0.0:4000 ./web_server_folder{RESET}
    {YELLOW}and open the browser on{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#print/world{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#upper/world{RESET}
    {YELLOW}This will return an error:{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#upper/WORLD{RESET}
    {YELLOW}If all is fine, run{RESET}
{GREEN}cargo auto release{RESET}
"#
    );
}

/// wasm-pack build --release
fn task_release() {
    let cargo_toml = cl::CargoToml::read();
    cl::auto_version_increment_semver_or_date();
    cl::auto_cargo_toml_to_md();
    cl::auto_lines_of_code("");

    cl::run_shell_command_static("cargo fmt").unwrap_or_else(|e| panic!("{e}"));
    cl::run_shell_command_static("wasm-pack build --target web").unwrap_or_else(|e| panic!("{e}"));
    cl::run_shell_command_static("\\rsync -a --delete-after pkg/ web_server_folder/cargo_auto_template_new_wasm/pkg/").unwrap_or_else(|e| panic!("{e}"));
    println!(
        r#"
    {YELLOW}After `cargo auto build`, open port 4000 in VSCode and run the basic web server{RESET}
    {YELLOW}in a separate VSCode bash terminal, so it can serve constantly in the background.{RESET}
{GREEN}basic-http-server -a 0.0.0.0:4000 ./web_server_folder{RESET}
    {YELLOW}and open the browser on{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm{RESET}    
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#print/world{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#upper/world{RESET}
    {YELLOW}This will return an error:{RESET}
{GREEN}http://localhost:4000/cargo_auto_template_new_wasm#upper/WORLD{RESET}
    {YELLOW}If all is fine, run{RESET}
{GREEN}cargo auto doc{RESET}
"#
    );
    print_examples_cmd();
}

/// cargo doc, then copies to /docs/ folder, because this is a GitHub standard folder
fn task_doc() {
    let cargo_toml = cl::CargoToml::read();
    cl::auto_cargo_toml_to_md();
    cl::auto_lines_of_code("");
    cl::auto_plantuml(&cargo_toml.package_repository().unwrap());
    cl::auto_playground_run_code();
    cl::auto_md_to_doc_comments();

    cl::run_shell_command_static("cargo doc --no-deps --document-private-items").unwrap_or_else(|e| panic!("{e}"));
    // copy target/doc into docs/ because it is GitHub standard
    cl::run_shell_command_static("rsync -a --info=progress2 --delete-after target/doc/ docs/").unwrap_or_else(|e| panic!("{e}"));

    // Create simple index.html file in docs directory
    let mut shell_command_sanitized =
        cl::ShellCommandLimitedDoubleQuotesSanitizer::new(r#"printf "<meta http-equiv=\"refresh\" content=\"0; url={url_sanitized_for_double_quote}/index.html\" />\n" > docs/index.html"#);
    shell_command_sanitized.replace_placeholder_forbidden_double_quotes("{url_sanitized_for_double_quote}", &cargo_toml.package_name().replace("-", "_"));
    shell_command_sanitized.run();

    // pretty html
    cl::auto_doc_tidy_html().unwrap();
    cl::run_shell_command_static("cargo fmt").unwrap_or_else(|e| panic!("{e}"));
    // message to help user with next move
    println!(
        r#"
    {YELLOW}After `cargo auto doc`, ctrl-click on `docs/index.html`. 
    It will show the index.html in VSCode Explorer, then right-click and choose "Show Preview".
    This works inside the CRUSTDE container, because of the extension "Live Preview" 
    <https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server>
    If ok then run the tests in code and the documentation code examples.{RESET}
{GREEN}cargo auto test{RESET}
"#
    );
}

/// cargo test
fn task_test() {
    println!(r#"    {YELLOW}Wasm is a cdylib and therefore doc-tests are not run !{RESET}"#);
    cl::run_shell_command_static("cargo test").unwrap_or_else(|e| panic!("{e}"));
    println!(
        r#"
    {YELLOW}After `cargo auto test`. If ok then {RESET}
    {YELLOW}(commit message is mandatory){RESET}
{GREEN}cargo auto commit_and_push "message"{RESET}
"#
    );
}

/// commit and push
fn task_commit_and_push(arg_2: Option<String>) {
    let Some(message) = arg_2 else {
        eprintln!("{RED}Error: Message for commit is mandatory.{RESET}");
        // early exit
        return;
    };

    // If needed, ask to create new local git repository
    if !cl::git_is_local_repository() {
        cl::new_local_repository(&message).unwrap();
    }

    // If needed, ask to create a GitHub remote repository
    if !cl::git_has_remote() {
        let github_client = github_mod::GitHubClient::new_with_stored_token();
        cgl::new_remote_github_repository(&github_client).unwrap();
        cgl::description_and_topics_to_github(&github_client);
    } else {
        let github_client = github_mod::GitHubClient::new_with_stored_token();
        // if description or topics/keywords/tags have changed
        cgl::description_and_topics_to_github(&github_client);

        // separate commit for docs if they changed, to not make a lot of noise in the real commit
        if std::path::Path::new("docs").exists() {
            cl::run_shell_command_static(r#"git add docs && git diff --staged --quiet || git commit -m "update docs" "#).unwrap_or_else(|e| panic!("{e}"));
        }

        cl::add_message_to_unreleased(&message);
        // the real commit of code
        let mut shell_command_sanitized = cl::ShellCommandLimitedDoubleQuotesSanitizer::new(r#"git add -A && git diff --staged --quiet || git commit -m "{message_sanitized_for_double_quote}" "#);
        shell_command_sanitized.replace_placeholder_forbidden_double_quotes("{message_sanitized_for_double_quote}", &message);
        shell_command_sanitized.run();

        cl::run_shell_command_static("git push").unwrap_or_else(|e| panic!("{e}"));
    }

    println!(
        r#"
    {YELLOW}After `cargo auto commit_and_push "message"`{RESET}
{GREEN}cargo auto publish_to_crates_io{RESET}
"#
    );
}

/// publish to web
fn task_publish_to_web() {
    let cargo_toml = cl::CargoToml::read();
    // take care of tags
    let tag_name_version = cl::git_tag_sync_check_create_push(&version);

    // Find the filename of the identity_file for ssh connection to host_name, to find out if need ssh-add or not.
    // parse the ~/.ssh/config. 99% probably there should be a record for host_name and there is the identity_file.
    // else ask user for filename, then run ssh-add
    cl::ssh_add_resolve("project_homepage","bestia_dev_ssh_1");

    // rsync to copy to server over ssh
    // TODO: sanitize
    let shell_command = format!(
        r#"rsync -e ssh -a --info=progress2 --delete-after ~/rustprojects/{package_name}/web_server_folder/ project_author@project_homepage:/var/www/project_homepage/pwa_short_name/"#,
        package_name = cargo_toml.package_name()
    );
    cl::run_shell_command(&shell_command);

    println!(
        r#"{YELLOW}
    After `cargo auto publish_to_web`, 
    check 
https://bestia.dev/{package_name}
{RESET}"#,
        package_name = cargo_toml.package_name()
    );
}

/// create a new release on github
fn task_github_new_release() {
    let cargo_toml = cl::CargoToml::read();
    let version = cargo_toml.package_version();
    // take care of tags
    let tag_name_version = cl::git_tag_sync_check_create_push(&version);

    let owner = cargo_toml.github_owner().unwrap();
    let repo_name = cargo_toml.package_name();
    let now_date = cl::now_utc_date_iso();
    let release_name = format!("Version {} ({})", &version, now_date);
    let branch = "main";

    // First, the user must write the content into file RELEASES.md in the section ## Unreleased.
    // Then the automation task will copy the content to GitHub release
    let body_md_text = cl::body_text_from_releases_md().unwrap();

    let github_client = github_mod::GitHubClient::new_with_stored_token();
    let json_value = github_client.send_to_github_api(cgl::github_api_create_new_release(&owner, &repo_name, &tag_name_version, &release_name, branch, &body_md_text));
    // early exit on error
    if let Some(error_message) = json_value.get("message") {
        eprintln!("{RED}{error_message}{RESET}");
        if let Some(errors) = json_value.get("errors") {
            let errors = errors.as_array().unwrap();
            for error in errors.iter() {
                if let Some(code) = error.get("code") {
                    eprintln!("{RED}{code}{RESET}");
                }
            }
        }
        panic!("{RED}Call to GitHub API returned an error.{RESET}")
    }

    // Create a new Version title in RELEASES.md.
    cl::create_new_version_in_releases_md(&release_name).unwrap();

    println!(
        "
    {YELLOW}New GitHub release created: {release_name}.{RESET}
"
    );
/*
    // region: upload asset only for executables, not for libraries

    let release_id = json_value.get("id").unwrap().as_i64().unwrap().to_string();
    println!(
        "
        {YELLOW}Now uploading release asset. This can take some time if the files are big. Wait...{RESET}
    "
    );
    // compress files tar.gz
    let tar_name = format!("{repo_name}-{tag_name_version}-x86_64-unknown-linux-gnu.tar.gz");

    let mut shell_command_sanitized =
        cl::ShellCommandLimitedDoubleQuotesSanitizer::new(r#"tar -zcvf "{tar_name_sanitized_for_double_quote}" "target/release/{repo_name_sanitized_for_double_quote}" "#);
    shell_command_sanitized.replace_placeholder_forbidden_double_quotes("{tar_name_sanitized_for_double_quote}", &tar_name);
    shell_command_sanitized.replace_placeholder_forbidden_double_quotes("{repo_name_sanitized_for_double_quote}", &repo_name);
    shell_command_sanitized.run();

    // upload asset
    cgl::github_api_upload_asset_to_release(&github_client, &owner, &repo_name, &release_id, &tar_name);

    let mut shell_command_sanitized = cl::ShellCommandLimitedDoubleQuotesSanitizer::new(r#"rm "{tar_name_sanitized_for_double_quote}" "#);
    shell_command_sanitized.replace_placeholder_forbidden_double_quotes("{tar_name_sanitized_for_double_quote}", &tar_name);
    shell_command_sanitized.run();

    println!(
        r#"
    {YELLOW}Asset uploaded. Open and edit the description on GitHub Releases in the browser.{RESET}
    "#
    );

    // endregion: upload asset only for executables, not for libraries

*/
    println!(
        r#"
{GREEN}https://github.com/{owner}/{repo_name}/releases{RESET}
    "#
    );
}
// endregion: tasks
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/src/secrets_always_local_mod.rs",
        file_content: r###"// secrets_always_local_mod.rs

/// Secrets like GitHub API token, crates.io token, SSH private key passphrase and similar
/// must never go out of this crate. Never pass any secret to an external crate library as much as possible.
/// The user has the source code under his fingers in this crate. So he knows nobody will mess with this code
/// once he inspected and reviewed it.
/// All the modules are in one file to avoid clutter in the automation_tasks_rs folder.
/// The simple program flow of functions that need secrets is butchered to avoid secrets leaving this crate.
/// Now it looks like a mess, but the goal is achieved. The secrets never leave this crate.

pub(crate) mod decrypt_mod {

    use cargo_auto_lib::RED;
    use cargo_auto_lib::RESET;
    use secrecy::ExposeSecret;

    /// The secrets must not leave this crate.
    /// They are never going into an external library crate.
    /// This crate is "user code" and is easy to review and inspect.
    pub(crate) struct Decryptor<'a> {
        secret_string: secrecy::SecretString,
        secret_passcode_bytes: &'a secrecy::SecretVec<u8>,
    }

    impl<'a> Decryptor<'a> {
        pub(crate) fn new_for_decrypt(secret_passcode_bytes: &'a secrecy::SecretVec<u8>) -> Self {
            Decryptor {
                secret_string: secrecy::SecretString::new("".to_string()),
                secret_passcode_bytes,
            }
        }
        pub(crate) fn return_secret_string(&self) -> &secrecy::SecretString {
            &self.secret_string
        }

        /// Decrypts encrypted_string with secret_passcode_bytes
        ///
        /// secret_passcode_bytes must be 32 bytes or more
        /// Returns the secret_string
        pub(crate) fn decrypt_symmetric(&mut self, encrypted_string: &cargo_auto_encrypt_secret_lib::EncryptedString) {
            let encrypted_bytes = <base64ct::Base64 as base64ct::Encoding>::decode_vec(&encrypted_string.0).unwrap();
            //only first 32 bytes
            let mut secret_passcode_32bytes = [0u8; 32];
            secret_passcode_32bytes.copy_from_slice(&self.secret_passcode_bytes.expose_secret()[0..32]);

            let cipher = <aes_gcm::Aes256Gcm as aes_gcm::KeyInit>::new(&secret_passcode_32bytes.into());
            // nonce is salt
            let nonce = rsa::sha2::digest::generic_array::GenericArray::from_slice(&encrypted_bytes[..12]);
            let cipher_text = &encrypted_bytes[12..];

            let Ok(decrypted_bytes) = aes_gcm::aead::Aead::decrypt(&cipher, nonce, cipher_text) else {
                panic!("{RED}Error: Decryption failed. {RESET}");
            };
            let decrypted_string = String::from_utf8(decrypted_bytes).unwrap();
            self.secret_string = secrecy::SecretString::new(decrypted_string)
        }
    }
}

pub(crate) mod encrypt_mod {

    use cargo_auto_lib::RED;
    use cargo_auto_lib::RESET;

    // bring trait to scope
    use secrecy::ExposeSecret;

    /// The secrets must not leave this crate.
    /// They are never going into an external library crate.
    /// This crate is "user code" and is easy to review and inspect.
    pub(crate) struct Encryptor<'a> {
        secret_string: secrecy::SecretString,
        secret_passcode_bytes: &'a secrecy::SecretVec<u8>,
    }

    impl<'a> Encryptor<'a> {
        pub(crate) fn new_for_encrypt(secret_string: secrecy::SecretString, secret_passcode_bytes: &'a secrecy::SecretVec<u8>) -> Self {
            Encryptor { secret_string, secret_passcode_bytes }
        }

        /// Encrypts secret_string with secret_passcode_bytes
        ///
        /// secret_passcode_bytes must be 32 bytes or more
        /// returns the encrypted_string
        pub(crate) fn encrypt_symmetric(&self) -> Option<cargo_auto_encrypt_secret_lib::EncryptedString> {
            //only first 32 bytes
            let mut secret_passcode_32bytes = [0u8; 32];
            secret_passcode_32bytes.copy_from_slice(&self.secret_passcode_bytes.expose_secret()[0..32]);

            let cipher = <aes_gcm::Aes256Gcm as aes_gcm::KeyInit>::new(&secret_passcode_32bytes.into());
            // nonce is salt
            let nonce = <aes_gcm::Aes256Gcm as aes_gcm::AeadCore>::generate_nonce(&mut aes_gcm::aead::OsRng);

            let Ok(cipher_text) = aes_gcm::aead::Aead::encrypt(&cipher, &nonce, self.secret_string.expose_secret().as_bytes()) else {
                panic!("{RED}Error: Encryption failed. {RESET}");
            };

            let mut encrypted_bytes = nonce.to_vec();
            encrypted_bytes.extend_from_slice(&cipher_text);
            let encrypted_string = <base64ct::Base64 as base64ct::Encoding>::encode_string(&encrypted_bytes);
            Some(cargo_auto_encrypt_secret_lib::EncryptedString(encrypted_string))
        }
    }
}

pub(crate) mod secrecy_mod {

    //! The crate secrecy is probably great.
    //! But I want to encrypt the content, so I will make a wrapper.
    //! The secrets must always be moved to secrecy types as soon as possible.

    use cargo_auto_encrypt_secret_lib::EncryptedString;

    pub struct SecretEncryptedString {
        encrypted_string: EncryptedString,
    }

    impl SecretEncryptedString {
        pub fn new_with_secret_string(secret_string: secrecy::SecretString, session_passcode: &secrecy::SecretVec<u8>) -> Self {
            let encryptor = super::encrypt_mod::Encryptor::new_for_encrypt(secret_string, &session_passcode);
            let encrypted_string = encryptor.encrypt_symmetric().unwrap();

            SecretEncryptedString { encrypted_string }
        }

        pub fn new_with_string(secret_string: String, session_passcode: &secrecy::SecretVec<u8>) -> Self {
            let secret_string = secrecy::SecretString::new(secret_string);
            Self::new_with_secret_string(secret_string, session_passcode)
        }

        pub fn expose_decrypted_secret(&self, session_passcode: &secrecy::SecretVec<u8>) -> secrecy::SecretString {
            let mut decryptor = super::decrypt_mod::Decryptor::new_for_decrypt(&session_passcode);
            decryptor.decrypt_symmetric(&self.encrypted_string);
            decryptor.return_secret_string().clone()
        }
    }
}

pub(crate) mod ssh_mod {

    #[allow(unused_imports)]
    use cargo_auto_lib::BLUE;
    use cargo_auto_lib::GREEN;
    use cargo_auto_lib::RED;
    use cargo_auto_lib::RESET;
    use cargo_auto_lib::YELLOW;

    use crate::secrets_always_local_mod::*;

    // bring trait into scope
    use secrecy::ExposeSecret;

    pub struct SshContext {
        signed_passcode_is_a_secret: secrecy::SecretVec<u8>,
        decrypted_string: secrecy::SecretString,
    }

    impl SshContext {
        pub fn new() -> Self {
            SshContext {
                signed_passcode_is_a_secret: secrecy::SecretVec::new(vec![]),
                decrypted_string: secrecy::SecretString::new("".to_string()),
            }
        }
        pub fn get_decrypted_string(&self) -> secrecy::SecretString {
            self.decrypted_string.clone()
        }
    }

    impl cargo_auto_encrypt_secret_lib::SshContextTrait for SshContext {
        /// decrypt from file data and write the decrypted secret in private field for later use in this crate, not in external library crates
        fn decrypt_from_file_data(&mut self, encrypted_string: &cargo_auto_encrypt_secret_lib::EncryptedString) {
            let mut decryptor = decrypt_mod::Decryptor::new_for_decrypt(&self.signed_passcode_is_a_secret);
            decryptor.decrypt_symmetric(encrypted_string);
            self.decrypted_string = decryptor.return_secret_string().clone();
        }

        /// get token and encrypt
        fn get_token_and_encrypt(&self) -> cargo_auto_encrypt_secret_lib::EncryptedString {
            /// Internal function used only for test configuration
            ///
            /// It is not interactive, but reads from a env var.
            #[cfg(test)]
            fn get_token() -> secrecy::SecretString {
                secrecy::SecretString::new(std::env::var("TEST_TOKEN").unwrap())
            }
            /// Internal function get_passphrase interactively ask user to type the passphrase
            ///
            /// This is used for normal code execution.
            #[cfg(not(test))]
            fn get_token() -> secrecy::SecretString {
                eprintln!(" ");
                eprintln!("   {BLUE}Enter the API token to encrypt:{RESET}");
                secrecy::SecretString::new(
                    inquire::Password::new("")
                        .without_confirmation()
                        .with_display_mode(inquire::PasswordDisplayMode::Masked)
                        .prompt()
                        .unwrap(),
                )
            }
            let token_is_a_secret = get_token();
            // use this signed as password for symmetric encryption
            let encryptor = encrypt_mod::Encryptor::new_for_encrypt(token_is_a_secret, &self.signed_passcode_is_a_secret);

            let encrypted_token = encryptor.encrypt_symmetric().unwrap();
            // return
            encrypted_token
        }

        /// Sign with ssh-agent or with identity_file
        ///
        /// get passphrase interactively
        /// returns secret_password_bytes:Vec u8
        fn sign_with_ssh_agent_or_identity_file(&mut self, identity_private_file_path: &camino::Utf8Path, seed_bytes_not_a_secret: &[u8; 32]) {
            /// Internal function used only for test configuration
            ///
            /// It is not interactive, but reads from a env var.
            #[cfg(test)]
            fn get_passphrase() -> secrecy::SecretString {
                secrecy::SecretString::new(std::env::var("TEST_PASSPHRASE").unwrap())
            }
            /// Internal function get_passphrase interactively ask user to type the passphrase
            ///
            /// This is used for normal code execution.
            #[cfg(not(test))]
            fn get_passphrase() -> secrecy::SecretString {
                eprintln!(" ");
                eprintln!("   {BLUE}Enter the passphrase for the SSH private key:{RESET}");
                secrecy::SecretString::new(
                    inquire::Password::new("")
                        .without_confirmation()
                        .with_display_mode(inquire::PasswordDisplayMode::Masked)
                        .prompt()
                        .unwrap(),
                )
            }

            let identity_private_file_path_expanded = cargo_auto_encrypt_secret_lib::file_path_home_expand(identity_private_file_path);
            if !camino::Utf8Path::new(&identity_private_file_path_expanded).exists() {
                eprintln!("{RED}Identity file {identity_private_file_path_expanded} that contains the SSH private key does not exist! {RESET}");
                eprintln!("    {YELLOW}Create the SSH key manually in bash with this command:{RESET}");
                if identity_private_file_path_expanded.as_str().contains("github_api") {
                    eprintln!(r#"{GREEN}ssh-keygen -t ed25519 -f \"{identity_private_file_path_expanded}\" -C \"github api token\"{RESET}"#);
                } else if identity_private_file_path_expanded.as_str().contains("github_api") {
                    eprintln!(r#"{GREEN}ssh-keygen -t ed25519 -f \"{identity_private_file_path_expanded}\" -C \"crates io token\"{RESET}"#);
                }
                eprintln!(" ");
                panic!("{RED}Error: File {identity_private_file_path_expanded} does not exist! {RESET}");
            }

            let fingerprint_from_file = cargo_auto_encrypt_secret_lib::get_fingerprint_from_file(&identity_private_file_path_expanded);

            let mut ssh_agent_client = cargo_auto_encrypt_secret_lib::crate_ssh_agent_client();
            match cargo_auto_encrypt_secret_lib::ssh_add_list_contains_fingerprint(&mut ssh_agent_client, &fingerprint_from_file) {
                Some(public_key) => {
                    // sign with public key from ssh-agent
                    let signature_is_the_new_secret_password = ssh_agent_client.sign(&public_key, seed_bytes_not_a_secret).unwrap();
                    // only the data part of the signature goes into as_bytes.
                    self.signed_passcode_is_a_secret = secrecy::SecretVec::new(signature_is_the_new_secret_password.as_bytes().to_owned());
                }
                None => {
                    // ask user to think about adding with ssh-add
                    eprintln!("   {YELLOW}SSH key for encrypted token is not found in the ssh-agent.{RESET}");
                    eprintln!("   {YELLOW}Without ssh-agent, you will have to type the private key passphrase every time. This is more secure, but inconvenient.{RESET}");
                    eprintln!("   {YELLOW}You can manually add the SSH identity to ssh-agent for 1 hour:{RESET}");
                    eprintln!("   {YELLOW}WARNING: using ssh-agent is less secure, because there is no need for user interaction.{RESET}");
                    eprintln!("{GREEN}ssh-add -t 1h {identity_private_file_path_expanded}{RESET}");

                    // just for test purpose I will use env var to read this passphrase. Don't use it in production.

                    let passphrase_is_a_secret = get_passphrase();
                    let private_key = ssh_key::PrivateKey::read_openssh_file(identity_private_file_path_expanded.as_std_path()).unwrap();
                    let mut private_key = private_key.decrypt(passphrase_is_a_secret.expose_secret()).unwrap();

                    // FYI: this type of signature is compatible with ssh-agent because it does not involve namespace
                    let signature_is_the_new_secret_password = rsa::signature::SignerMut::try_sign(&mut private_key, seed_bytes_not_a_secret).unwrap();

                    // only the data part of the signature goes into as_bytes.
                    self.signed_passcode_is_a_secret = secrecy::SecretVec::new(signature_is_the_new_secret_password.as_bytes().to_owned());
                }
            }
        }
    }
}

pub(crate) mod github_mod {

    //! Every API call needs the GitHub API token. This is a secret important just like a password.
    //! I don't want to pass this secret to an "obscure" library crate that is difficult to review.
    //! This secret will stay here in this codebase that every developer can easily inspect.
    //! Instead of the token, I will pass the struct GitHubClient with the trait SendToGitHubApi.
    //! This way, the secret token will be encapsulated.

    use cargo_auto_github_lib as cgl;

    use cargo_auto_lib::BLUE;
    use cargo_auto_lib::RED;
    use cargo_auto_lib::RESET;

    use reqwest::Client;
    // bring trait into scope
    use secrecy::ExposeSecret;

    /// Struct GitHubClient contains only private fields
    /// This fields are accessible only to methods in implementation of traits.
    pub struct GitHubClient {
        /// Passcode for encrypt the token_is_a_secret to encrypted_token in memory.
        /// So that the secret is in memory as little as possible as plain text.
        /// For every session (program start) a new random passcode is created.
        session_passcode: secrecy::SecretVec<u8>,

        /// private field is set only once in the new() constructor
        encrypted_token: super::secrecy_mod::SecretEncryptedString,
    }

    impl GitHubClient {
        /// Create new GitHub client
        ///
        /// Interactively ask the user to input the GitHub token.
        pub fn new_interactive_input_token() -> Self {
            let mut github_client = Self::new_wo_token();

            println!("{BLUE}Enter the GitHub API token:{RESET}");
            github_client.encrypted_token =
                super::secrecy_mod::SecretEncryptedString::new_with_string(inquire::Password::new("").without_confirmation().prompt().unwrap(), &github_client.session_passcode);

            // return
            github_client
        }

        /// Create new GitHub client without token
        fn new_wo_token() -> Self {
            /// Internal function Generate a random password
            fn random_byte_passcode() -> [u8; 32] {
                let mut password = [0_u8; 32];
                use aes_gcm::aead::rand_core::RngCore;
                aes_gcm::aead::OsRng.fill_bytes(&mut password);
                password
            }

            let session_passcode = secrecy::SecretVec::new(random_byte_passcode().to_vec());
            let encrypted_token = super::secrecy_mod::SecretEncryptedString::new_with_string("".to_string(), &session_passcode);

            GitHubClient { session_passcode, encrypted_token }
        }

        /// Use the stored API token
        ///
        /// If the token not exists ask user to interactively input the token.
        /// To decrypt it, use the SSH passphrase. That is much easier to type than typing the token.
        /// it is then possible also to have the ssh key in ssh-agent and write the passphrase only once.
        /// But this great user experience comes with security concerns. The token is accessible if the attacker is very dedicated.
        pub fn new_with_stored_token() -> Self {
            /// Internal function for DRY Don't Repeat Yourself
            fn read_token_and_decrypt_return_github_client(mut ssh_context: super::ssh_mod::SshContext, encrypted_string_file_path: &camino::Utf8Path) -> GitHubClient {
                // read the token and decrypt
                cargo_auto_encrypt_secret_lib::decrypt_with_ssh_interactive_from_file(&mut ssh_context, encrypted_string_file_path);
                let token_is_a_secret = ssh_context.get_decrypted_string();
                let mut github_client = GitHubClient::new_wo_token();
                github_client.encrypted_token = super::secrecy_mod::SecretEncryptedString::new_with_secret_string(token_is_a_secret, &github_client.session_passcode);
                github_client
            }

            let encrypted_string_file_path = camino::Utf8Path::new("~/.ssh/github_api_token_encrypted.txt");
            let encrypted_string_file_path_expanded = cargo_auto_encrypt_secret_lib::file_path_home_expand(encrypted_string_file_path);

            let identity_file_path = camino::Utf8Path::new("~/.ssh/github_api_token_ssh_1");
            if !encrypted_string_file_path_expanded.exists() {
                // ask interactive
                println!("    {BLUE}Do you want to store the GitHub API token encrypted with an SSH key? (y/n){RESET}");
                let answer = inquire::Text::new("").prompt().unwrap();
                if answer.to_lowercase() != "y" {
                    // enter the token manually, not storing
                    return Self::new_interactive_input_token();
                } else {
                    // get the passphrase and token interactively
                    let mut ssh_context = super::ssh_mod::SshContext::new();
                    // encrypt and save the encrypted token
                    cargo_auto_encrypt_secret_lib::encrypt_with_ssh_interactive_save_file(&mut ssh_context, identity_file_path, encrypted_string_file_path);
                    // read the token and decrypt, return GitHubClient
                    read_token_and_decrypt_return_github_client(ssh_context, encrypted_string_file_path)
                }
            } else {
                // file exists
                let ssh_context = super::ssh_mod::SshContext::new();
                // read the token and decrypt, return GitHubClient
                read_token_and_decrypt_return_github_client(ssh_context, encrypted_string_file_path)
            }
        }

        /// decrypts the secret token in memory
        pub fn decrypt_token_in_memory(&self) -> secrecy::SecretString {
            self.encrypted_token.expose_decrypted_secret(&self.session_passcode)
        }
    }

    /// trait from the crate library, so the 2 crates can share a function
    impl cgl::SendToGitHubApi for GitHubClient {
        /// Send GitHub API request
        ///
        /// This function encapsulates the secret API token.
        /// The RequestBuilder is created somewhere in the library crate.
        /// The client can be passed to the library. It will not reveal the secret token.
        fn send_to_github_api(&self, req: reqwest::blocking::RequestBuilder) -> serde_json::Value {
            // I must build the request to be able then to inspect it.
            let req = req.bearer_auth(self.decrypt_token_in_memory().expose_secret()).build().unwrap();

            // region: Assert the correct url and https
            // It is important that the request coming from a external crate/library
            // is only sent always and only to GitHub API and not some other malicious url,
            // because the request contains the secret GitHub API token.
            // And it must always use https
            let host_str = req.url().host_str().unwrap();
            assert!(host_str == "api.github.com", "{RED}Error: Url is not correct: {host_str}. It must be always api.github.com.{RESET}");
            let scheme = req.url().scheme();
            assert!(scheme == "https", "{RED}Error: Scheme is not correct: {scheme}. It must be always https.{RESET}");
            // endregion: Assert the correct url and https

            let reqwest_client = reqwest::blocking::Client::new();
            let response_text = reqwest_client.execute(req).unwrap().text().unwrap();

            let json_value: serde_json::Value = serde_json::from_str(&response_text).unwrap();

            // panic if "message": String("Bad credentials"),
            if let Some(m) = json_value.get("message") {
                if m == "Bad credentials" {
                    panic!("{RED}Error: Bad credentials for GitHub API. {RESET}");
                }
            }

            // return
            json_value
        }

        /// Upload to GitHub
        ///
        /// This function encapsulates the secret API token.
        /// The RequestBuilder is created somewhere in the library crate.
        /// The client can be passed to the library. It will not reveal the secret token.
        /// This is basically an async fn, but use of `async fn` in public traits is discouraged...
        async fn upload_to_github(&self, req: reqwest::RequestBuilder) -> serde_json::Value {
            // I must build the request to be able then to inspect it.
            let req = req.bearer_auth(self.decrypt_token_in_memory().expose_secret()).build().unwrap();

            // region: Assert the correct url and https
            // It is important that the request coming from a external crate/library
            // is only sent always and only to GitHub uploads and not some other malicious url,
            // because the request contains the secret GitHub API token.
            // And it must always use https
            let host_str = req.url().host_str().unwrap();
            assert!(host_str == "uploads.github.com", "{RED}Error: Url is not correct: {host_str}. It must be always api.github.com.{RESET}");
            let scheme = req.url().scheme();
            assert!(scheme == "https", "{RED}Error: Scheme is not correct: {scheme}. It must be always https.{RESET}");
            // endregion: Assert the correct url and https

            let reqwest_client = Client::new();
            let response_text = reqwest_client.execute(req).await.unwrap().text().await.unwrap();

            let json_value: serde_json::Value = serde_json::from_str(&response_text).unwrap();

            // panic if "message": String("Bad credentials"),
            if let Some(m) = json_value.get("message") {
                if m == "Bad credentials" {
                    panic!("{RED}Error: Bad credentials for GitHub API. {RESET}");
                }
            }

            // return
            json_value
        }
    }
}

pub(crate) mod crate_io_mod {

    //! Publish to crates.io needs the crates.io token. This is a secret important just like a password.
    //! I don't want to pass this secret to an "obscure" library crate that is difficult to review.
    //! This secret will stay here in this codebase that every developer can easily inspect.
    //! Instead of the token, I will pass the struct CratesIoClient with the trait SendToCratesIo.
    //! This way, the secret token will be encapsulated.

    use cargo_auto_lib::BLUE;
    use cargo_auto_lib::RED;
    use cargo_auto_lib::RESET;
    use cargo_auto_lib::YELLOW;

    // bring trait into scope
    use secrecy::ExposeSecret;

    /// Struct CratesIoClient contains only private fields
    /// This fields are accessible only to methods in implementation of traits.
    pub struct CratesIoClient {
        /// Passcode for encrypt the token_is_a_secret to encrypted_token in memory.
        /// So that the secret is in memory as little as possible as plain text.
        /// For every session (program start) a new random passcode is created.
        session_passcode: secrecy::SecretVec<u8>,

        /// private field is set only once in the new() constructor
        encrypted_token: super::secrecy_mod::SecretEncryptedString,
    }

    impl CratesIoClient {
        /// Create new CratesIo client
        ///
        /// Interactively ask the user to input the crates.io token.
        #[allow(dead_code)]
        pub fn new_interactive_input_token() -> Self {
            let mut crates_io_client = Self::new_wo_token();

            println!("{BLUE}Enter the crates.io token:{RESET}");
            crates_io_client.encrypted_token =
                super::secrecy_mod::SecretEncryptedString::new_with_string(inquire::Password::new("").without_confirmation().prompt().unwrap(), &crates_io_client.session_passcode);

            // return
            crates_io_client
        }

        /// Create new CratesIo client without token
        #[allow(dead_code)]
        fn new_wo_token() -> Self {
            /// Internal function Generate a random password
            fn random_byte_passcode() -> [u8; 32] {
                let mut password = [0_u8; 32];
                use aes_gcm::aead::rand_core::RngCore;
                aes_gcm::aead::OsRng.fill_bytes(&mut password);
                password
            }

            let session_passcode = secrecy::SecretVec::new(random_byte_passcode().to_vec());
            let encrypted_token = super::secrecy_mod::SecretEncryptedString::new_with_string("".to_string(), &session_passcode);

            CratesIoClient { session_passcode, encrypted_token }
        }

        /// Use the stored crates.io token
        ///
        /// If the token not exists ask user to interactively input the token.
        /// To decrypt it, use the SSH passphrase. That is much easier to type than typing the token.
        /// It is then possible also to have the ssh key in ssh-agent and write the passphrase only once.
        /// But this great user experience comes with security concerns. The token is accessible if the attacker is very dedicated.
        #[allow(dead_code)]
        pub fn new_with_stored_token() -> Self {
            /// Internal function for DRY Don't Repeat Yourself
            fn read_token_and_decrypt_return_crate_io_client(mut ssh_context: super::ssh_mod::SshContext, encrypted_string_file_path: &camino::Utf8Path) -> CratesIoClient {
                cargo_auto_encrypt_secret_lib::decrypt_with_ssh_interactive_from_file(&mut ssh_context, encrypted_string_file_path);
                let token_is_a_secret = ssh_context.get_decrypted_string();
                let mut crates_io_client = CratesIoClient::new_wo_token();
                crates_io_client.encrypted_token = super::secrecy_mod::SecretEncryptedString::new_with_secret_string(token_is_a_secret, &crates_io_client.session_passcode);
                crates_io_client
            }

            let encrypted_string_file_path = camino::Utf8Path::new("~/.ssh/crates_io_token_encrypted.txt");
            let encrypted_string_file_path_expanded = cargo_auto_encrypt_secret_lib::file_path_home_expand(encrypted_string_file_path);

            let identity_file_path = camino::Utf8Path::new("~/.ssh/crates_io_token_ssh_1");
            if !encrypted_string_file_path_expanded.exists() {
                // ask interactive
                println!("    {BLUE}Do you want to store the crates.io token encrypted with an SSH key? (y/n){RESET}");
                let answer = inquire::Text::new("").prompt().unwrap();
                if answer.to_lowercase() != "y" {
                    // enter the token manually, not storing
                    return Self::new_interactive_input_token();
                } else {
                    // get the passphrase and token interactively
                    let mut ssh_context = super::ssh_mod::SshContext::new();
                    // encrypt and save the encrypted token
                    cargo_auto_encrypt_secret_lib::encrypt_with_ssh_interactive_save_file(&mut ssh_context, identity_file_path, encrypted_string_file_path);
                    // read the token and decrypt, return CratesIoClient
                    read_token_and_decrypt_return_crate_io_client(ssh_context, encrypted_string_file_path)
                }
            } else {
                // file exists
                let ssh_context = super::ssh_mod::SshContext::new();
                // read the token and decrypt, return CratesIoClient
                read_token_and_decrypt_return_crate_io_client(ssh_context, encrypted_string_file_path)
            }
        }

        /// decrypts the secret token in memory
        pub fn decrypt_token_in_memory(&self) -> secrecy::SecretString {
            self.encrypted_token.expose_decrypted_secret(&self.session_passcode)
        }

        /// Publish to crates.io
        ///
        /// This function encapsulates the secret crates.io token.
        /// The client can be passed to the library. It will not reveal the secret token.
        pub fn publish_to_crates_io(&self) {
            // print command without the token
            println!("{YELLOW}cargo publish --token [REDACTED]{RESET}");
            let shell_command = format!("cargo publish --token {}", self.decrypt_token_in_memory().expose_secret());
            let status = std::process::Command::new("sh").arg("-c").arg(shell_command).spawn().unwrap().wait().unwrap();
            let exit_code = status.code().expect(&format!("{RED}Error: publish to crates.io error. {RESET}"));
            if exit_code != 0 {
                panic!("{RED}Error: publish to crates.io error {exit_code}. {RESET}");
            }
        }
    }
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/Cargo.toml",
        file_content: r###"[package]
name = "automation_tasks_rs"
version = "1.0.0"
authors = ["bestia.dev"]
homepage = "https://bestia.dev"
edition = "2021"
description = "Automation tasks coded in Rust language for the workflow of Rust projects"
publish = false

[dependencies]
cargo_auto_lib = "2.2.1"
cargo_auto_github_lib = "1.0.4"
cargo_auto_encrypt_secret_lib = "1.0.7"

inquire = "0.7.0"
serde_json = {version= "1.0.114", features=["std"]}

# the version of reqwest must be the same as the version in the library cargo_auto_github_lib
reqwest = { version = "0.12.3", features = ["blocking", "stream"] }

camino = "1.1.6"
aes-gcm = "0.10.3"
ssh-key = { version = "0.6.4", features = [ "rsa", "encryption"] }
rsa = { version = "0.9.6", features = ["sha2","pem"] }
secrecy = { version="0.8.0", features=["alloc"]}
base64ct = {version = "1.6.0", features = ["alloc"] }

tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter", "std", "fmt", "time"] }
tracing-appender="0.2.2"
time = {version="0.3.36", features=["macros","local-offset"]}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "automation_tasks_rs/.vscode/settings.json",
        file_content: r###"{
    "workbench.colorCustomizations": {
        "titleBar.activeForeground": "#fff",
        "titleBar.inactiveForeground": "#ffffffcc",
        "titleBar.activeBackground": "#a81c1c",
        "titleBar.inactiveBackground": "#630b0bcc"
    },
    "spellright.language": [
        "en"
    ],
    "spellright.documentTypes": [
        "markdown",
        "latex",
        "plaintext"
    ],
    "files.associations": {
        "LICENSE": "plain text"
    },
    "rust-analyzer.showUnlinkedFileNotification": false,
    "cSpell.words": [
        "Alla",
        "alloc",
        "appender",
        "bestia",
        "bestiadev",
        "camino",
        "CRUSTDE",
        "decryptor",
        "encryptor",
        "endregion",
        "keygen",
        "Nazdravlje",
        "new_cli",
        "octocrab",
        "passcode",
        "plantuml",
        "Prost",
        "reqwest",
        "rustdevuser",
        "rustprojects",
        "serde",
        "sshadd",
        "struct",
        "subsecond",
        "substack",
        "thiserror",
        "zcvf",
        "zdravje",
        "zeroize"
    ]
}"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "RELEASES.md",
        file_content: r###"# Releases changelog of cargo_auto_template_new_wasm

All notable changes to this project will be documented in this file.  
This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).  
The library releases will be published on crates.io.  
The cargo-auto automation task will use the content of the section `## Unreleased` to create
the GitHub release consistently with this file.  
The ongoing changes that are not released, are visible in the git commits and github pull requests.  
The TODO section is part of the [README.md](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm).  

## Unreleased

## Version 0.0.1

- Rust project created with `cargo auto new_wasm cargo_auto_template_new_wasm`
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "src/main_mod.rs",
        file_content: r###"// src/main_mod.rs
// This module is like a main.rs module for a binary CLI executable.
// The `main_mod.rs` contains all input/output interface stuff.
// So the program logic can be separate from the interface.

// The `lib_mod.rs` must not contains any input/output interface stuff.
// This `lib_mod.rs` can then be used as dependency crate for other projects.

// The `main_mod.rs` uses the `anyhow` error library.
// The `lib_mod.rs` uses the `thiserror` library.

use unwrap::unwrap;
use wasm_rs_dbg::dbg;

mod lib_mod;
pub use lib_mod::wsm;
pub use lib_mod::LibraryError;

/// entry point just like for cli-bin-executable
pub fn main() {
    // logging is essential for every project
    wasm_logger::init(wasm_logger::Config::default());
    log::info!("main() started");

    // super simple argument parsing.
    // In browser we can use 'local routing' on url path with # fragment
    // http://localhost:4000/cargo_auto_template_new_wasm#arg_1/arg_2
    let location = wsm::window().location();
    let mut location_hash_fragment = unwrap!(location.hash());
    // dbg! is now writing to the console, crate wasm-rs-dbg
    dbg!(&location_hash_fragment);

    // in std::env::args() the nth(0) is the exe name. Let's make it similar.
    if !location_hash_fragment.is_empty() {
        // replace # with delimiter /
        location_hash_fragment.replace_range(..1, "/");
    }
    let location_hash_fragment = format!("cargo_auto_template_new_wasm{}", location_hash_fragment);
    dbg!(&location_hash_fragment);
    let args = location_hash_fragment.split("/");
    let args: Vec<&str> = args.collect();
    dbg!(&args);

    remove_downloading_message();

    // Since &str is Copy, you can avoid the creation of &&str by adding .copied()
    match args.get(1).copied() {
        None => page_with_inputs(),
        Some("help") => print_help(),
        Some("print") => {
            match args.get(2).copied() {
                // second argument
                Some(greet_name) => print_greet_name(greet_name),
                None => wsm::set_html_element_inner_text("div_for_errors", "Error: Missing second argument for print."),
            }
        }
        Some("upper") => {
            match args.get(2).copied() {
                // second argument
                Some(greet_name) => {
                    // this can return an error. Here is the last place I can deal with the error.
                    match upper_greet_name(greet_name) {
                        // do nothing
                        Ok(()) => (),
                        // log error from anyhow
                        Err(err) => wsm::set_html_element_inner_text("div_for_errors", &format!("Error: {err}")),
                    }
                }
                None => wsm::set_html_element_inner_text("div_for_errors", "Error: Missing second argument for upper."),
            }
        }
        _ => wsm::set_html_element_inner_text(
            "div_for_errors",
            "Error: Unrecognized arguments. Try \n http://localhost:4000/cargo_auto_template_new_wasm#help",
        ),
    }
}

/// print help
fn print_help() {
    wsm::set_html_element_inner_text(
        "div_for_wasm_html_injecting",
        r#"
    Welcome to cargo_auto_template_new_wasm !
    
    This is a simple yet complete template for a WASM program written in Rust.
    The file structure is on purpose similar to a Rust CLI project and accepts similar arguments.

    http://localhost:4000/cargo_auto_template_new_wasm
    http://localhost:4000/cargo_auto_template_new_wasm#help
    http://localhost:4000/cargo_auto_template_new_wasm#print/world
    http://localhost:4000/cargo_auto_template_new_wasm#upper/world

    This command should return an error:
    http://localhost:4000/cargo_auto_template_new_wasm#upper/WORLD

    © 2024 bestia.dev  MIT License github.com/automation-tasks-rs/cargo-auto
"#,
    );
}

/// render first page
pub fn page_with_inputs() {
    // rust has `Raw string literals` that are great!
    // just add r# before the starting double quotes and # after the ending double quotes.
    let html = r#"
<h1>Template_new_wasm</h1>
<p>Write a command in the Argument 1: print or upper</p>
<div class="input-wrap">
    <label for="arg_1">Argument 1:</label>  
    <input style="width:20%;" type="text" id="arg_1" value="upper"/>
</div>
<p>Write a name in the Argument 2: world or WORLD</p>
<div class="input-wrap">
    <label for="arg_2">Argument 2:</label>  
    <input style="width:20%;" type="text" id="arg_2" value="world"/>
</div>
<p>Click on Run</p>
<div class="input-wrap">
    <input type="button" class="button" id="btn_run" value="Run"/>
</div>
<p class="small">bestia.dev</p>
        "#;

    // WARNING for HTML INJECTION! Never put user provided strings in set_html_element_inner_html.
    // Only correctly html encoded strings can use this function.
    wsm::set_html_element_inner_html("div_for_wasm_html_injecting", html);
    wsm::add_listener_to_button("btn_run", &on_click_btn_run);
}

/// the listener calls this function
fn on_click_btn_run() {
    let arg_1 = wsm::get_input_element_value_string_by_id("arg_1");
    let arg_2 = wsm::get_input_element_value_string_by_id("arg_2");
    if !arg_1.is_empty() && !arg_2.is_empty() {
        // pass arguments as URL in a new tab
        let url = format!("/cargo_auto_template_new_wasm#{arg_1}/{arg_2}");
        wsm::open_url_in_new_tab(&url);
    } else {
        // write on the same web page
        wsm::set_html_element_inner_text("div_for_errors", &format!("Error: Both arguments are mandatory."));
    }
}

// remove downloading message
fn remove_downloading_message() {
    wsm::set_html_element_inner_text("div_for_wasm_html_injecting", "");
}

/// print my name
fn print_greet_name(greet_name: &str) {
    wsm::set_html_element_inner_text(
        "div_for_wasm_html_injecting",
        &format!(
            r#"The result is
{}
"#,
            lib_mod::format_hello_phrase(greet_name)
        ),
    );
}

/// print my name upper, can return error
fn upper_greet_name(greet_name: &str) -> anyhow::Result<()> {
    // the function from `lib.rs`, can return error
    // use the ? syntax to bubble the error up one level or continue (early return)
    let upper = lib_mod::format_upper_hello_phrase(greet_name)?;
    wsm::set_html_element_inner_text(
        "div_for_wasm_html_injecting",
        &format!(
            r#"The result is
{upper}
"#
        ),
    );
    // return
    Ok(())
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "src/main_mod/lib_mod/web_sys_mod.rs",
        file_content: r###"//! src/web_sys_mod.rs
//! helper functions for web_sys, window, document, dom, console,
//! Trying to isolate/hide all javascript code and conversion here.

// region: use
// the macro unwrap! shows the TRUE location where the error has ocurred.
use unwrap::unwrap;
use wasm_bindgen::prelude::*;
use wasm_bindgen::{JsCast, JsValue};
// use wasm_bindgen_futures::JsFuture;
use web_sys::console;
// use web_sys::{Request, RequestInit, Response};
// endregion: use

/// return the global window object
pub fn window() -> web_sys::Window {
    unwrap!(web_sys::window())
}

/// get element by id
pub fn get_element_by_id(element_id: &str) -> web_sys::Element {
    let document = unwrap!(window().document());
    unwrap!(document.get_element_by_id(element_id))
}

/// debug write into session_storage
pub fn debug_write(text: &str) {
    // writing to the console
    console::log_1(&JsValue::from_str(text));
}

/// get html element by id
pub fn get_html_element_by_id(element_id: &str) -> web_sys::HtmlElement {
    let element = get_element_by_id(element_id);
    let html_element: web_sys::HtmlElement = unwrap!(element.dyn_into::<web_sys::HtmlElement>());
    //return
    html_element
}

/// get input element value string by id
pub fn get_input_element_value_string_by_id(element_id: &str) -> String {
    // debug_write("before get_element_by_id");
    let input_element = get_element_by_id(element_id);
    // debug_write("before dyn_into");
    let input_html_element = unwrap!(input_element.dyn_into::<web_sys::HtmlInputElement>());
    // debug_write("before value()");
    input_html_element.value()
}

/// add event listener for button
pub fn add_listener_to_button(element_id: &str, fn_on_click_button: &'static (dyn Fn() + 'static)) {
    let handler_1 = Box::new(move || {
        fn_on_click_button();
    }) as Box<dyn FnMut()>;
    let closure = Closure::wrap(handler_1);

    let html_element = get_html_element_by_id(element_id);
    html_element.set_onclick(Some(closure.as_ref().unchecked_ref()));
    closure.forget();
}

/// set inner text
pub fn set_html_element_inner_text(element_id: &str, inner_text: &str) {
    let html_element = get_html_element_by_id(element_id);
    html_element.set_inner_text(inner_text);
}

/// WARNING for HTML INJECTION! Never put user provided strings in set_html_element_inner_html.
/// Only correctly html encoded strings can use this function.
/// set inner html into dom
pub fn set_html_element_inner_html(element_id: &str, inner_html: &str) {
    let html_element = get_element_by_id(element_id);
    html_element.set_inner_html(inner_html);
}

// open URL in new tab
pub fn open_url_in_new_tab(url: &str) {
    window().open_with_url_and_target(url, "_blank").unwrap();
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "src/main_mod/lib_mod/hello_mod.rs",
        file_content: r###"// src/hello_mod.rs

//! All the real code is inside modules in separate files (program logic).
//!
//! This doc-comments will be compiled into the `docs`.

/// format the hello phrase
pub fn format_hello_phrase(greet_name: &str) -> String {
    log::info!("start format_hello_phrase()");
    // return
    format!("Hello {}!", greet_name)
}

/// format the hello phrase with uppercase name
/// if it is already uppercase, return error with thiserror
pub fn format_upper_hello_phrase(greet_name: &str) -> Result<String, crate::LibraryError> {
    log::info!("start format_upper_hello_phrase()");
    // shadowing the same variable name:
    let upper_greet_name = make_uppercase(greet_name);
    if upper_greet_name == greet_name {
        return Err(crate::LibraryError::Uppercase(greet_name.to_string()));
    }

    // return
    Ok(format!("Hello {}!", &upper_greet_name))
}

/// return uppercase
pub fn make_uppercase(greet_name: &str) -> String {
    // return
    greet_name.to_uppercase()
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    pub fn test_format_upper_hello_phrase() {
        assert_eq!(format_upper_hello_phrase("abcd").expect("error"), "Hello ABCD!");
        assert!(format_upper_hello_phrase("ABCD").is_err());
    }

    #[test]
    pub fn test_make_uppercase() {
        assert_eq!(make_uppercase("abcd"), "ABCD");
        assert_eq!(make_uppercase("1234abcd"), "1234ABCD");
        assert_eq!(make_uppercase("čšž"), "ČŠŽ");
    }
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "src/main_mod/lib_mod.rs",
        file_content: r###"// src/lib_mod.rs
// This module is like a lib.rs module for a binary CLI executable.
// The `lib_mod.rs` must not contains any input/output interface stuff.
// So the program logic can be separate from the interface.

// The `main_mod.rs` contains all input/output interface stuff.
// This `lib_mod.rs` can then be used as dependency crate for other projects.

// The `lib_mod.rs` does not have any real code. All the code is in modules in separate files.
// The `lib_mod.rs` has just the list of modules, it publishes module's functions or class for the caller
// and it has some global stuff like the Error enum.

// The `main_mod.rs` uses the `anyhow` error library.
// The `lib_mod.rs` uses the `thiserror` library.

use thiserror::Error;

// Instead of a hello_mod local module, we could use a UI agnostic crate library dependency.
// So the same library could be used for CLI and for WASM, that have vastly different UI.
mod hello_mod;

pub mod web_sys_mod;
pub use web_sys_mod as wsm;

pub use hello_mod::format_hello_phrase;
pub use hello_mod::format_upper_hello_phrase;

/// all possible library errors for `thiserror`
#[derive(Error, Debug)]
pub enum LibraryError {
    #[error("Name `{0}` is already uppercase.")]
    Uppercase(String),
    #[error("Unknown error.")]
    Unknown,
}

// ANSI colors for Linux terminal
// https://github.com/shiena/ansicolor/blob/master/README.md
#[allow(dead_code)]
pub const RED: &str = "\x1b[31m";
#[allow(dead_code)]
pub const YELLOW: &str = "\x1b[33m";
#[allow(dead_code)]
pub const GREEN: &str = "\x1b[32m";
#[allow(dead_code)]
pub const RESET: &str = "\x1b[0m";
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "src/lib.rs",
        file_content: r###"// src/lib.rs
// This file has just the wasm_bindgen_start() function
// and calls into main_mod.rs.
// So the structure of the project modules can be similar to a binary CLI executable.

// region: auto_md_to_doc_comments include README.md A //!

// endregion: auto_md_to_doc_comments include README.md A //!

use wasm_bindgen::prelude::*;

mod main_mod;
pub use main_mod::wsm;
pub use main_mod::LibraryError;

#[wasm_bindgen(start)]
/// To start the Wasm application, wasm_bindgen runs this functions
pub fn wasm_bindgen_start() -> Result<(), JsValue> {
    // Initialize debugging for when/if something goes wrong.
    console_error_panic_hook::set_once();
    // write the app version just for debug purposes
    wsm::debug_write(&format!("cargo_auto_template_new_wasm v{}", env!("CARGO_PKG_VERSION")));

    main_mod::main();
    // return
    Ok(())
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: ".github/workflows/rust_fmt_auto_build_test.yml",
        file_content: r###"name: rust_fmt_auto_build_test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  rust_fmt_auto_build_test:

    runs-on: ubuntu-latest

    steps:
    - name: checkout
      uses: actions/checkout@v4

    - name: cargo fmt -- --check
      run: cargo fmt -- --check

    - name: Run cache for rust dependencies
      uses: Swatinem/rust-cache@v2.7.3

    - name: Configure sccache
      run: printf "RUSTC_WRAPPER=sccache\n" >> $GITHUB_ENV; printf "SCCACHE_GHA_ENABLED=true\n" >> $GITHUB_ENV

    - name: Run sccache-cache for artifacts
      uses: mozilla-actions/sccache-action@v0.0.4

    - name: install and cache cargo-auto
      uses: baptiste0928/cargo-install@v3.0.0
      with:
        crate: cargo-auto

    - name: Cache for automation tasks
      uses: actions/cache@v4.0.0
      with:
        path: |
          /home/runner/work/cargo-auto/cargo-auto/automation_tasks_rs/.file_hashes.json 
          /home/runner/work/cargo-auto/cargo-auto/automation_tasks_rs/target 
          /home/runner/work/cargo-auto/cargo-auto/automation_tasks_rs/Cargo.toml
        key: automation_tasks_rs

    - name: cargo auto build
      run: cargo auto build

    - name: cargo auto test
      run: cargo auto test
      
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: ".github/workflows/docs_pages.yml",
        file_content: r###"# Simple workflow for deploying static content to GitHub Pages
name: docs_pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Single deploy job since we're just deploying
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Pages
        uses: actions/configure-pages@v4
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Upload entire repository
          path: 'docs'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "web_server_folder/cargo_auto_template_new_wasm/css/basic_style.css",
        file_content: r###"html { 
    font-family: sans-serif;
    background-color: #000000;
    color: #FBF462;
}

h1{
    margin-left: auto;
    margin-right: auto;
    text-align: center;
}
p{
    margin-left: auto;
    margin-right: auto;
    text-align: center;
}
.small{
    font-size: 10px;
}

.input-wrap {
    position: relative;
	text-align: center;
  }

.button {
    display: inline-block;
    padding: 12px 18px;
    cursor: pointer;
    border-radius: 5px;
    background-color: #8ebf42;
    font-size: 16px;
    font-weight: bold;
    color: #fff;
  }

  .fc_red{
    color: red;
}
"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "web_server_folder/cargo_auto_template_new_wasm/index.html",
        file_content: r###"<!DOCTYPE html>
<html lang="en">

<head>
      <!-- classic header for a web page -->
      <title>cargo_auto_template_new_wasm</title>
      <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
      <meta name="Description" content="template for a minimal wasm project for browser">
      <meta name="author" content="https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm">    
      <link rel="stylesheet" href="css/basic_style.css">
      
</head>

<body>
      <!-- warning if javascript iis not enabled -->
      <noscript>
            <h2>
                  !!!???!!!<br>
                  This web app <br>
                  cannot work <br>
                  without javascript<br>
                  enabled<br>
                  !!!???!!!</h2>
      </noscript>
      <!-- display a text while waiting for wasm download. 
      This content will change from the wasm code.-->
      <div id="div_for_wasm_html_injecting">
            <h2>
                  Waiting to<br>
                  download <br>
                  the web app...<br>
                  This is <br>
                  very quick on fast<br>
                  networks...<br>
            </h2>
      </div>
      <p class="fc_red" id="div_for_errors"></p>
      <!-- import and init the wasm code -->
      <script type="module">
            import init from "./pkg/cargo_auto_template_new_wasm.js";
            async function run() {
                  await init();
            }
            run();
      </script>
</body>

</html>"###,
    });
    vec_file.push(crate::FileItem {
        file_name: "Cargo.toml",
        file_content: r###"[package]
name = "cargo_auto_template_new_wasm"
version = "0.0.1"
authors = ["bestia.dev"]
homepage = "https://bestia.dev"
edition = "2021"
description = "template for a minimal wasm project for browser"
repository = "https://github.com/github_owner/cargo_auto_template_new_wasm"
readme = "README.md"
license = "MIT"
# Keyword must be only one word: lowercase letters, hyphens(-) or numbers, less then 35 characters, at most 5 keywords per crate
keywords = ["maintained", "work-in-progress", "rustlang", "wasm"]
categories = ["wasm"]
publish = false

[lib]
# cdylib is for the wasm module library
crate-type = ["cdylib"]

[dependencies]
unwrap = "1.2.1"
wasm-bindgen = "0.2.86"
console_error_panic_hook = "0.1.7"
js-sys = "0.3.63"
thiserror="1.0.40"
anyhow="1.0.71"
log = "0.4.17"
wasm-logger = "0.2.0"
wasm-rs-dbg = {version="0.1.2", default-features = false, features = ["console-log"]}

[dependencies.web-sys]
version = "0.3.63"
features = [
  "console",
  "Document",
  "Element",
  "HtmlElement",
  "HtmlInputElement",
  "Location",
  "Window",
]

[dev-dependencies]
wasm-bindgen-test = "0.3.36"

[profile.release]
panic = "abort"
"###,
    });
    vec_file.push(crate::FileItem{
            file_name :"DEVELOPMENT.md",
            file_content : r###"# Development details

## CRUSTDE - Containerized Rust Development Environment

I recommend using the CRUSTDE - Containerized Rust Development Environment to write Rust projects. Follow the instructions here <https://github.com/CRUSTDE-ContainerizedRustDevEnv/crustde_cnt_img_pod>.  

It is an isolated development environment that will not mess with you system.
It will work on Linux (tested on Debian) and inside WSL (Windows Subsystem for Linux).

You just need to install the newer alternative to Docker: [podman](https://podman.io/). Then you download the prepared container image from DockerHub (3GB). And then a little juggling with ssh keys. All this is simplified by running a few bash scripts. Just follow the easy instructions.  

The container image contains cargo, rustc, wasm-pack, basic-http-server, cargo-auto and other utils that a Rust project needs.  

## Workflow with automation_tasks_rs and cargo-auto

For easy workflow, use the automation tasks that are already coded in the sub-project `automation_tasks_rs`. This is a basic workflow:

```bash
cargo auto build
cargo auto release
cargo auto doc
cargo auto test
cargo auto commit_and push
cargo auto publish_to_crates_io
cargo auto github_new_release
```

Every task finishes with instructions how to proceed.  
The [cargo-auto](https://github.com/automation-tasks-rs/cargo-auto) and [dev_bestia_cargo_completion](https://github.com/automation-tasks-rs/dev_bestia_cargo_completion) are already installed inside the CRUSTDE container.

You can open the automation sub-project in VSCode and then code your own tasks in Rust.

```bash
code automation_tasks_rs
```

## HTML, CSS

The simple static HTML and CSS files are in `web_server_folder/cargo_auto_template_new_wasm`.  
Then the Rust code injects html elements into the DOM.  

## Web server and wasm

The browser security does not allow the loading of WASM modules from local files. It needs to be loaded from a web server. The CRUSTDE container has the [basic-http-server](https://github.com/brson/basic-http-server) already installed.  

Run the server in a second VSCode terminal, so it can keep running all the time.  

```bash
basic-http-server -a 0.0.0.0:4000 ./web_server_folder
```

In the first VSCode terminal, we can build the project.  
Then in the browser, we can refresh the page <http://localhost:4000/cargo_auto_template_new_wasm> with F5 to see the changes.  

## Rust and wasm

In the `Cargo.toml` it is important to define the output as wasm library and the required dependencies to web-sys, js-sys, and wasm-bindgen.  
Wasm starts from the `src/lib.rs`. On purpose, I added the `main_mod.rs` and `lib_mod.rs` to make the project structure similar to a Rust CLI project.  
The User Interface UI is completely different in-browser than in a CLI, but we can reuse the libraries if they are UI agnostic.  
It is smart to split a project so that the logic does not contain anything about the UI.

## GitHub

This template contains GitHub actions to build the project on commit and publish the documentation on GutHub pages.  
"###,
});
    vec_file.push(crate::FileItem {
        file_name: "LICENSE",
        file_content: r###"MIT License

Copyright (c) 2024 bestia.dev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"###,
    });
    vec_file.push(crate::FileItem{
            file_name :"README.md",
            file_content : r###"[//]: # (auto_md_to_doc_comments segment start A)

# cargo_auto_template_new_wasm

[//]: # (auto_cargo_toml_to_md start)

**template for a minimal wasm project for browser**  
***version: 0.0.1 date: 2024-02-21 author: [bestia.dev](https://bestia.dev) repository: [GitHub](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm)***  

[//]: # (auto_cargo_toml_to_md end)

  [![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/blob/master/LICENSE)

[//]: # (auto_lines_of_code start)

[![Lines in Rust code](https://img.shields.io/badge/Lines_in_Rust-264-green.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/)
[![Lines in Doc comments](https://img.shields.io/badge/Lines_in_Doc_comments-28-blue.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/)
[![Lines in Comments](https://img.shields.io/badge/Lines_in_comments-69-purple.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/)
[![Lines in examples](https://img.shields.io/badge/Lines_in_examples-0-yellow.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/)
[![Lines in tests](https://img.shields.io/badge/Lines_in_tests-16-orange.svg)](https://github.com/automation-tasks-rs/cargo_auto_template_new_wasm/)

[//]: # (auto_lines_of_code end)

Hashtags: #maintained #ready-for-use #rustlang #automation #workflow  
My projects on GitHub are more like a tutorial than a finished product: [bestia-dev tutorials](https://github.com/bestia-dev/tutorials_rust_wasm).  
I recommend using the [CRUSTDE - Containerized Rust Development Environment](https://github.com/CRUSTDE-ContainerizedRustDevEnv/crustde_cnt_img_pod) to write Rust projects on Linux, isolated from your system.  

## This template

Just like `cargo new` makes a soft and gentle introduction to Rust projects and development, I want to make the same for an in-browser WASM project with 

```bash
cargo auto new_wasm project_name
```

Extremely simple, just the basic moving parts and use cases.  
This simplest template does not have a PWA implementation or dedicated web server app.

## Development details

Read the development details in a separate md file:
[DEVELOPMENT.md](DEVELOPMENT.md)

## Releases changelog

Read the releases changelog in a separate md file:
[RELEASES.md](RELEASES.md)

## TODO

And code happily ever after...

## Open-source and free as a beer

My open-source projects are free as a beer (MIT license).  
I just love programming.  
But I need also to drink. If you find my projects and tutorials helpful, please buy me a beer by donating to my [PayPal](https://paypal.me/LucianoBestia).  
You know the price of a beer in your local bar ;-)  
So I can drink a free beer for your health :-)  
[Na zdravje!](https://translate.google.com/?hl=en&sl=sl&tl=en&text=Na%20zdravje&op=translate) [Alla salute!](https://dictionary.cambridge.org/dictionary/italian-english/alla-salute) [Prost!](https://dictionary.cambridge.org/dictionary/german-english/prost) [Nazdravlje!](https://matadornetwork.com/nights/how-to-say-cheers-in-50-languages/) 🍻

[//bestia.dev](https://bestia.dev)  
[//github.com/bestia-dev](https://github.com/bestia-dev)  
[//bestiadev.substack.com](https://bestiadev.substack.com)  
[//youtube.com/@bestia-dev-tutorials](https://youtube.com/@bestia-dev-tutorials)  

[//]: # (auto_md_to_doc_comments segment end A)
"###,
});
    vec_file.push(crate::FileItem {
        file_name: ".vscode/settings.json",
        file_content: r###"{
    "workbench.colorCustomizations": {
        "titleBar.activeForeground": "#fff",
        "titleBar.inactiveForeground": "#ffffffcc",
        "titleBar.activeBackground": "#477587",
        "titleBar.inactiveBackground": "#3F758DCC"
    },
    "spellright.language": [
        "en"
    ],
    "spellright.documentTypes": [
        "markdown",
        "latex",
        "plaintext"
    ],
    "files.associations": {
        "LICENSE": "plain text"
    },
    "rust-analyzer.showUnlinkedFileNotification": false,
    "cSpell.words": [
        "zdravje",
        "zcvf",
        "substack",
        "struct",
        "Prost",
        "Nazdravlje",
        "bestiadev",
        "Alla",
        "apos",
        "bestia",
        "bindgen",
        "cdylib",
        "CRUSTDE",
        "endregion",
        "onchange",
        "onclick",
        "plantuml",
        "rustc",
        "rustlang",
        "thiserror",
        "webassembly"
    ]
}"###,
    });
    // endregion: files copied into strings by automation tasks

    // return
    vec_file
}
